import math
import matplotlib.pyplot as plt
import random
import numpy as np
'''
Making a modular fractal transformation chaosgame
'''
def f_a(x,y):
    """ transformation function for a
    """
    new_x = 0.5*x + 0.25
    new_y = 0.5*y + math.sqrt(3)/4
    return new_x, new_y

def f_b(x,y):
    """ transformation function for b
    """
    new_x = 0.5*x
    new_y = 0.5*y
    return new_x, new_y    

def f_c(x,y):
    """ transformation function for c
    """
    new_x = 0.5*x + 0.5
    new_y = 0.5*y
    return new_x, new_y
'''
User initializer
'''
num_states = 3
num_transformers = 3
transformers = [f_a, f_b, f_c]
transition_matric = [[[0], [1,2],[2]],
                    [[0], [0],[0]],
                    [[1],[1],[1]]]
x_points = []
y_points = []
int_seq =  [] #this will be the num_state sequence
trans_seq = [] #this will keep track of the transformations used before a new point is created
starting_state = 0
x = int(input("what is the initial x value?"))
y = int(input("what is your initial y value?"))
'''
Here below is supposed to be a one size fits all code
'''
def modular_fractal(x,y,starting_state): #what is the starting point and what is the state to check for when we need to generate a new point
    current_state = starting_state #setting the current_state to the inital starting
    for i in range(0,10): #iterate through this 1000 times
        print(i)
        print(x_points) #keeping track of x coordinates
        print(y_points) #keeping track of y coordinates
        if starting_state == current_state: #check if we are at the starting state
            x_points.append(x) #add to x coordinate
            y_points.append(y) #add to y coordinate
        next_state = random.randint(0, num_states-1) #determine which state we are going next
        int_seq.append(next_state) #tracking the next state
        num_options = len(transition_matric[current_state][next_state]) #look at the possible choices based what functinos are avaliable
        if num_options > 0: #we can pick an option
            transformer_choice = random.randint(0, num_options-1) #we are randomly choosing the transformer choice #this is an indedx
            next_transformer = transition_matric[current_state][next_state][transformer_choice]
            new_x, new_y = transformers[next_transformer](x, y) #we are selecting the transformation function
            x, y = new_x, new_y #this is the new starting point
            current_state = next_state
        else: #we picked an impossible path
            pass 
    return trans_seq

'''
This code will generate a sequence of transformations
'''
#transformation_seq = [] #starts empty but gets larger the more 
def seq_generator(starting_state): #this generates the sequence of transformations
    current_state = starting_state #setting the current_state to the inital starting
    fun_seq = []
    for i in range(0,1000): #iterate through this 1000 times
        print(i)
        if starting_state == current_state: #check if we are at the starting state
            if  len(fun_seq) > 0: # just to make sure the first point makes it in
                fun_seq.reverse()
                trans_seq.append(fun_seq)
                fun_seq = []
        next_state = random.randint(0, num_states-1) #determine which state we are going next
        num_options = len(transition_matric[current_state][next_state]) #look at the possible choices based what functinos are avaliable
        if num_options > 0: #we can pick an option
            transformer_choice = random.randint(0, num_options-1) #we are randomly choosing the transformer choice #this is an indedx
            next_transformer = transition_matric[current_state][next_state][transformer_choice]
            fun_seq.append(next_transformer) #appending the chosen function
            current_state = next_state
        else: #we picked an impossible path
            pass
    return trans_seq
#print(seq_generator(0))
starting_state = int(input("What is the starting state"))
#the_seq = seq_generator(starting_state)

'''
This function below will take the sequence generated by the function above and apply the functions based on the list of transformations
'''
def f_generator(x,y,seq_list): #it takes a list of sequences as an input and a starting x and y coordinate
    x_points.append(x) #append the first x value
    y_points.append(y) #append the first y value
    for i in range(0,len(seq_list)): #going through each element will be a transformation for each point
        print(i)
        for j in range(0,len(seq_list[i])): #going through this represents going through a state loop
            new_x,new_y = transformers[seq_list[i][j]](x, y) #apply the transformation
            x,y = new_x,new_y #set the new x,y values
        x_points.append(x) #append the new x point
        y_points.append(y) #append the new y point


'''
generalize version #it works I think
'''
def generalize_fractal_generator(x,y,starting_state,function_list,transformation_matrix): #this will take all variables into account
    seq_list = seq_generator(starting_state) # you need to take a starting state
    f_generator(x,y,seq_list)
    plt.scatter(x_points, y_points, s=1)
#    plt.plot(x_points,y_points,"o")
    plt.show()
generalize_fractal_generator(x,y,starting_state,transformers,transition_matric)
